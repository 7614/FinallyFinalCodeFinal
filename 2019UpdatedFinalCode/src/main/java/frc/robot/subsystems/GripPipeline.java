package frc.robot.subsystems;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.HashMap;

import edu.wpi.first.wpilibj.vision.VisionPipeline;

import org.opencv.core.*;
import org.opencv.core.Core.*;
import org.opencv.features2d.FeatureDetector;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.*;
import org.opencv.objdetect.*;

/**
* GripPipeline class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
public class GripPipeline implements VisionPipeline {

	//Outputs
	private Mat rgbThresholdOutput = new Mat();
	private Mat normalizeOutput = new Mat();
	private Mat maskOutput = new Mat();

	static {
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
	}

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	@Override	public void process(Mat source0) {
		// Step RGB_Threshold0:
		Mat rgbThresholdInput = source0;
		double[] rgbThresholdRed = {0.0, 255.0};
		double[] rgbThresholdGreen = {0.0, 0.8703146371418238};
		double[] rgbThresholdBlue = {0.0, 26.979527994227485};
		rgbThreshold(rgbThresholdInput, rgbThresholdRed, rgbThresholdGreen, rgbThresholdBlue, rgbThresholdOutput);

		// Step Normalize0:
		Mat normalizeInput = rgbThresholdOutput;
		int normalizeType = Core.NORM_MINMAX;
		double normalizeAlpha = 0.0;
		double normalizeBeta = 255;
		normalize(normalizeInput, normalizeType, normalizeAlpha, normalizeBeta, normalizeOutput);

		// Step Mask0:
		Mat maskInput = source0;
		Mat maskMask = normalizeOutput;
		mask(maskInput, maskMask, maskOutput);

	}

	/**
	 * This method is a generated getter for the output of a RGB_Threshold.
	 * @return Mat output from RGB_Threshold.
	 */
	public Mat rgbThresholdOutput() {
		return rgbThresholdOutput;
	}

	/**
	 * This method is a generated getter for the output of a Normalize.
	 * @return Mat output from Normalize.
	 */
	public Mat normalizeOutput() {
		return normalizeOutput;
	}

	/**
	 * This method is a generated getter for the output of a Mask.
	 * @return Mat output from Mask.
	 */
	public Mat maskOutput() {
		return maskOutput;
	}


	/**
	 * Segment an image based on color ranges.
	 * @param input The image on which to perform the RGB threshold.
	 * @param red The min and max red.
	 * @param green The min and max green.
	 * @param blue The min and max blue.
	 * @param output The image in which to store the output.
	 */
	private void rgbThreshold(Mat input, double[] red, double[] green, double[] blue,
		Mat out) {
		Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2RGB);
		Core.inRange(out, new Scalar(red[0], green[0], blue[0]),
			new Scalar(red[1], green[1], blue[1]), out);
	}

	/**
	 * Normalizes or remaps the values of pixels in an image.
	 * @param input The image on which to perform the Normalize.
	 * @param type The type of normalization.
	 * @param a The minimum value.
	 * @param b The maximum value.
	 * @param output The image in which to store the output.
	 */
	private void normalize(Mat input, int type, double a, double b, Mat output) {
		Core.normalize(input, output, a, b, type);
	}

	/**
	 * Filter out an area of an image using a binary mask.
	 * @param input The image on which the mask filters.
	 * @param mask The binary image that is used to filter.
	 * @param output The image in which to store the output.
	 */
	private void mask(Mat input, Mat mask, Mat output) {
		mask.convertTo(mask, CvType.CV_8UC1);
		Core.bitwise_xor(output, output, output);
		input.copyTo(output, mask);
	}


	

	



}

